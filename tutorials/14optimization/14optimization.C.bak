/*---------------------------------------------------------------------------*\
     ██╗████████╗██╗  ██╗ █████╗  ██████╗ █████╗       ███████╗██╗   ██╗
     ██║╚══██╔══╝██║  ██║██╔══██╗██╔════╝██╔══██╗      ██╔════╝██║   ██║
     ██║   ██║   ███████║███████║██║     ███████║█████╗█████╗  ██║   ██║
     ██║   ██║   ██╔══██║██╔══██║██║     ██╔══██║╚════╝██╔══╝  ╚██╗ ██╔╝
     ██║   ██║   ██║  ██║██║  ██║╚██████╗██║  ██║      ██║      ╚████╔╝
     ╚═╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝╚═╝  ╚═╝      ╚═╝       ╚═══╝

 * In real Time Highly Advanced Computational Applications for Finite Volumes
 * Copyright (C) 2017 by the ITHACA-FV authors
-------------------------------------------------------------------------------
License
    This file is part of ITHACA-FV
    ITHACA-FV is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    ITHACA-FV is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU Lesser General Public License for more details.
    You should have received a copy of the GNU Lesser General Public License
    along with ITHACA-FV. If not, see <http://www.gnu.org/licenses/>.
Description
    Example of a heat transfer Reduction Problem
SourceFiles
    14thermalBlock.C
\*---------------------------------------------------------------------------*/

#include <iostream>
#include "fvCFD.H"
#include "fvOptions.H"
#include "simpleControl.H"
#include "IOmanip.H"
#include "Time.H"
#include "laplacianProblem.H"
// #include "reducedLaplacian.H"
#include "ITHACAPOD.H"
#include "ITHACAutilities.H"
#include <Eigen/Dense>
#define _USE_MATH_DEFINES
#include <cmath>
#include "Foam2Eigen.H"


using namespace SPLINTER;

class thermocouplesPlane
{
    public:
    Eigen::VectorXd Ttrue;
    Eigen::VectorXd cellVol;
    Eigen::VectorXi cellID;
    Eigen::VectorXd Tdirect;
    Eigen::VectorXd Tsens;
    Eigen::VectorXd Tdiff;
};


class tutorial14: public laplacianProblem
{
    public:
     explicit tutorial14(int argc, char* argv[])
            :
            laplacianProblem(argc, argv),
            T(_T()),
            mesh(_mesh()),
	    runTime(_runTime())
        {}
        volScalarField& T;
        fvMesh& mesh;
        Time& runTime;
       
        int interpolation = 1;
        int cgIter = 0;
        int cgIterMax = 20;
	int thermocouplesRead = 0;
        const int thermocouplesNum = 15;
        double J = 10000; //cost funtion  [K^2] 
        double Jtol = 0.01;
        double k = 300; //thermal diffusivity [W/(mK)]
        double beta;
        double gamma = 0.0;
        double gamma_den = 0.0;
        double L2norm;
	double LinfNorm;
        scalar v = 0.0;
        scalar homogeneousBC = 0.0;
        scalar Tf = 300.0; //temperature at coldSide [K]

        label hotSide_ind = mesh.boundaryMesh().findPatchID("hotSide");
        
	Eigen::VectorXd g;           //Tentative heat flux at hotSide for the direct problem [W/m2]
        Eigen::VectorXd gTrue;       //True heat flux at hotSide [w/m2]  
        Eigen::VectorXd faceCellArea; //[m2]
        Eigen::VectorXd P;           //Search direction SHOULD BE [W/m2] BUT IT'S [K2/W]
        Eigen::VectorXd err; 
        Eigen::VectorXd gradJ;       //Gradient of the cost function 

	thermocouplesPlane interpolationPlane;
        Eigen::VectorXi thermocouplesCellID;
        Eigen::VectorXd Tmeas;   //Temperature at the thermocouples locations [K]
        Eigen::VectorXd Tdirect; 
        Eigen::VectorXd Tdiff;
        Eigen::VectorXd Tsens;   
        
        Eigen::VectorXd cellsInPlane;   
        
        void solveTrue()
        {
	    forAll (T.boundaryField()[hotSide_ind], faceI)
            {
               g.conservativeResize(faceI+1);
               g(faceI) = - 0.0;
            }
            forAll (T.boundaryField()[hotSide_ind], faceI)
            {
               gTrue.conservativeResize(faceI+1);
               gTrue(faceI) = - 100000 * mesh.boundaryMesh()[hotSide_ind].faceCentres()[faceI].z() * mesh.boundaryMesh()[hotSide_ind].faceCentres()[faceI].x();
            }
            //forAll (mesh.magSf().boundaryField()[hotSide_ind], faceI)
            //{
            //    faceCellArea.conservativeResize(faceI+1);
            //    faceCellArea(faceI) = mesh.magSf().boundaryField()[hotSide_ind][faceI];
            //}
            // True problem BC
            forAll(mesh.boundaryMesh(), patchI)
            {
               if(patchI == mesh.boundaryMesh().findPatchID("coldSide")){
                   ITHACAutilities::assignBC(T, patchI, Tf);
               }
               else if(patchI == mesh.boundaryMesh().findPatchID("hotSide")){
                   ITHACAutilities::assignBC(T, patchI, - gTrue /k);
               } 
               else{
                   ITHACAutilities::assignBC(T, patchI, homogeneousBC);
               }
            }
            solve(); 
	    readThermocouples();
            thermocouplesInterpolation();
        }

        void solveDirect()
        {
	    forAll(mesh.boundaryMesh(), patchI)
            {
               if(patchI == mesh.boundaryMesh().findPatchID("coldSide")){
                   ITHACAutilities::assignBC(T, patchI, Tf);
               }
               else if(patchI == mesh.boundaryMesh().findPatchID("hotSide")){
                   ITHACAutilities::assignBC(T, patchI, - g / k);
               }
               else{
                   ITHACAutilities::assignBC(T, patchI, homogeneousBC);
               }
            }
	    ITHACAutilities::assignIF(T, Tf);
            solve();
	    if(interpolation)
	    {
	        forAll(interpolationPlane.cellID, cellI)
		{
		    interpolationPlane.Tdirect(cellI) = T.internalField()[interpolationPlane.cellID (cellI)];
		}
	    }
	    else
	    {
	        forAll(thermocouplesCellID, cellI)
	        { 
	            Tdirect (cellI) = T.internalField()[thermocouplesCellID (cellI)];
	        }
	    }
	}
        
	void solveAdjoint()
        {
	    dimensionedScalar sourceDim("sourceDim", dimensionSet(0, 0, -1, 0, 0, 0, 0), 1);
	    forAll(mesh.boundaryMesh(), patchI)
            {
                ITHACAutilities::assignBC(T, patchI, homogeneousBC);
            }
            ITHACAutilities::assignIF(T, homogeneousBC);
            volScalarField f("f", T);
            
	    if(interpolation)
	    {
	        forAll(interpolationPlane.cellID, cellI)
		{
		    f.ref()[interpolationPlane.cellID (cellI)] = interpolationPlane.Tdiff(cellI) / k;
		}
	        
	    }
	    else
	    {
	        for(int i = 0; i < thermocouplesNum; i++){
                    f.ref()[thermocouplesCellID (i)] = Tdiff(i) / k ; /// mesh.V()[thermocouplesCellID (i)];
                }
	    }

	    simpleControl simple(mesh);
	    dimensionedScalar DT("DT", dimViscosity, 1.0);
            while (simple.loop())
            {
                Info<< "Time = " << runTime.timeName() << nl << endl;

                while (simple.correctNonOrthogonal())
                {
                    fvScalarMatrix TEqn
                    (
                        fvm::laplacian(DT, T) ==  - f * sourceDim
                    );

                    TEqn.solve();
                }
            }
            //Reinitializing runTime
            instantList Times = runTime.times();
            runTime.setTime(Times[1], 1);
	}

        void solveSensitivity()
        {
	    forAll(mesh.boundaryMesh(), patchI)
            {
                if(patchI == mesh.boundaryMesh().findPatchID("hotSide")){
                    ITHACAutilities::assignBC(T, patchI, - P / k);
                }
		else{
		    ITHACAutilities::assignBC(T, patchI, homogeneousBC);
		}
            }
	    ITHACAutilities::assignIF(T, homogeneousBC);
            solve(); 
	    if(interpolation)
	    {
	        forAll(interpolationPlane.cellID, cellI)
		{
		    interpolationPlane.Tsens(cellI) = T.internalField()[interpolationPlane.cellID (cellI)];
		}
	    }
	    else
	    {
	        forAll(thermocouplesCellID, cellI)
	        { 
	            Tsens (cellI) = T.internalField()[thermocouplesCellID (cellI)];
	        }
	    }
	}

        void solve()
        {
            ITHACAutilities::assignIF(T, homogeneousBC);
	    simpleControl simple(mesh);
	    dimensionedScalar DT("DT", dimViscosity, 1.0);
	    while (simple.loop())
            {
                Info<< "Time = " << runTime.timeName() << nl << endl;
        
                while (simple.correctNonOrthogonal())
                {
                    fvScalarMatrix TEqn
                    (
                        fvm::laplacian(DT, T)
                    );
        
                    //fvOptions.constrain(TEqn);
                    TEqn.solve();
                    //fvOptions.correct(T);
                }
            }
            //Reinitializing runTime
            instantList Times = runTime.times();
            runTime.setTime(Times[1], 1);
        }

        void readThermocouples()
	{
	    if(!thermocouplesRead)
	    {
                thermocouplesCellID.conservativeResize(thermocouplesNum);
                Tmeas.conservativeResize(thermocouplesNum);
                Tdirect.conservativeResize(thermocouplesNum);
                Tsens.conservativeResize(thermocouplesNum);
	        Tdiff.conservativeResize(thermocouplesNum);
	        
	        thermocouplesCellID (0)  = mesh.findCell(point( 0.3, 0.05, 0.3 ));
                thermocouplesCellID (1)  = mesh.findCell(point( 0.6, 0.05, 0.3 ));
                thermocouplesCellID (2)  = mesh.findCell(point( 0.9, 0.05, 0.3 ));
                thermocouplesCellID (3)  = mesh.findCell(point( 1.2, 0.05, 0.3 ));
                thermocouplesCellID (4)  = mesh.findCell(point( 1.5, 0.05, 0.3 ));

                thermocouplesCellID (5)  = mesh.findCell(point( 0.3, 0.05, 0.6 ));
                thermocouplesCellID (6)  = mesh.findCell(point( 0.6, 0.05, 0.6 ));
                thermocouplesCellID (7)  = mesh.findCell(point( 0.9, 0.05, 0.6 ));
                thermocouplesCellID (8)  = mesh.findCell(point( 1.2, 0.05, 0.6 ));
                thermocouplesCellID (9)  = mesh.findCell(point( 1.5, 0.05, 0.6 ));

                thermocouplesCellID (10) = mesh.findCell(point( 0.3, 0.05, 0.9 ));
                thermocouplesCellID (11) = mesh.findCell(point( 0.6, 0.05, 0.9 ));
                thermocouplesCellID (12) = mesh.findCell(point( 0.9, 0.05, 0.9 ));
                thermocouplesCellID (13) = mesh.findCell(point( 1.2, 0.05, 0.9 ));
                thermocouplesCellID (14) = mesh.findCell(point( 1.5, 0.05, 0.9 ));
	
	        forAll(thermocouplesCellID, cellI)
	        { 
	            Tmeas (cellI) = T.internalField()[thermocouplesCellID (cellI)];
	        }
	    }
	    else
	    {
	       WarningInFunction << "readThermocouples function called twice." << endl;
	       WarningInFunction << "I am not doing the second reading." << endl;
	    }
        }

	void conjugateGradient()
	{
            if( remove( "log.dat" ) != 0 )
                perror( "Error deleting file" );
            else
                puts( "File successfully deleted" );
            std::ofstream log("log.dat", std::ios_base::out | std::ios_base::app);
            std::cout.precision(5);
            log << "#  Iteration\t J\t L2norm\t LinfNorm\n" ; 
	    
	    while (cgIter < cgIterMax)
	    {
	        Info << "ITERATION " << cgIter+1 << endl;
		solveDirect();
                ITHACAstream::exportSolution(T, std::to_string(cgIter+1), "./results","Tdirect");
		if (conjugateGradientConvergenceCheck()){
		    log << std::scientific << cgIter+1 << "\t" << J << "\t" << L2norm << "\t" << LinfNorm << "\n";
                    log.close();
		    exit(10);
		}
		else{
		    log << std::scientific << cgIter+1 << "\t" << J << "\t" << L2norm << "\t" << LinfNorm << "\n";
		}
	        if(cgIter == 0){
		    P = g;
                    //err = g;
                    gradJ = g;
		}
		solveAdjoint();
		ITHACAstream::exportSolution(T, std::to_string(cgIter+1), "./results","lambda");

                forAll (T.boundaryField()[hotSide_ind], faceI)
                {
                   gradJ (faceI) = - T.boundaryField()[hotSide_ind][faceI]; 
                }

	        if(cgIter > 0)
		{
                    gamma = 0.0;
                    forAll (mesh.magSf().boundaryField()[hotSide_ind], faceI)
                    {
                        gamma += gradJ (faceI) * gradJ (faceI) * mesh.magSf().boundaryField()[hotSide_ind][faceI];
                    }
                    gamma = gamma / gamma_den;
                    Info << "gamma = " << gamma << endl;
                } 
                P = gradJ + gamma * P; //Updating P

		gamma_den = 0.0;
                forAll (mesh.magSf().boundaryField()[hotSide_ind], faceI)
                {
                    gamma_den +=  gradJ (faceI) * gradJ (faceI) * mesh.magSf().boundaryField()[hotSide_ind][faceI];
                }
                solveSensitivity();
		ITHACAstream::exportSolution(T, std::to_string(cgIter+1), "./results","Tsens");
	        
		if(interpolation)
		{
		    Eigen::VectorXd temp = interpolationPlane.Tdiff.array() * interpolationPlane.Tsens.array();
		    beta = temp.dot(interpolationPlane.cellVol);
		    temp = interpolationPlane.Tsens.array() * interpolationPlane.Tsens.array();
		    beta = beta / temp.dot(interpolationPlane.cellVol);
		}
		else
		{
		    beta = Tdiff.dot(Tsens) / Tsens.dot(Tsens);
		}
                Info << "beta = " << beta << endl;

                g = g - beta * P;
		cgIter += 1;
	    }
	}

	int conjugateGradientConvergenceCheck()
	{
	    if(interpolation)
	    {
	        Eigen::VectorXd sqTdiff;
	        interpolationPlane.Tdiff = interpolationPlane.Tdirect - interpolationPlane.Ttrue;
	        sqTdiff = interpolationPlane.Tdiff.array() * interpolationPlane.Tdiff.array();
                J = 0.5 * sqTdiff.dot(interpolationPlane.cellVol);
            }
	    else
	    {
	        Tdiff = Tdirect - Tmeas;
                J = 0.5 * Tdiff.dot(Tdiff);
	    }
            computeHeatFluxErrors();
	    writeHeatFluxFields();

            Info << "J =" << J << endl;

            if (J < Jtol)
            {
               Info << "Convergence reached in " << cgIter << " iterations" << endl;

               // Norms of the error
               std::cout << "L2 norm of the relative error = " << L2norm << " []" << std::endl;
               std::cout << "L infinity norm of the relative error = " << LinfNorm << " []" << std::endl;
               return (1);
            }
	    else
	    {
	        return (0);
	    }
	}
        
	void computeHeatFluxErrors()
	{
            unsigned int faceInSurfI = 0;
	    L2norm = 0.0;
	    LinfNorm = 0.0;
	    forAll (T.boundaryField()[hotSide_ind], faceI)
            {
	        auto fcx = mesh.boundaryMesh()[hotSide_ind].faceCentres()[faceI].x();
	        auto fcz = mesh.boundaryMesh()[hotSide_ind].faceCentres()[faceI].z();
		if(fcx >= mesh.C()[thermocouplesCellID (0)].component(0) &&
                   fcz >= mesh.C()[thermocouplesCellID (0)].component(2) &&
                   fcx <= mesh.C()[thermocouplesCellID (thermocouplesNum -1)].component(0) &&
                   fcz <= mesh.C()[thermocouplesCellID (thermocouplesNum -1)].component(2) 
		  )
		{
                    faceCellArea.conservativeResize(faceInSurfI+1);
	            err.conservativeResize(faceInSurfI+1);
                    faceCellArea(faceInSurfI) = mesh.magSf().boundaryField()[hotSide_ind][faceI];
	            err(faceInSurfI) = (g(faceI) - gTrue(faceI)) / gTrue(faceI);
		    LinfNorm = abs(err.maxCoeff());
		    L2norm += err(faceInSurfI) * err(faceInSurfI) *  faceCellArea(faceInSurfI);
		    faceInSurfI++;
		}
            }
	}

	void writeHeatFluxFields()
	{
	    unsigned int j = 0;
	    //Creating heatflux field to plot
	    volScalarField gField("g", T);
	    volScalarField gTrueField("gTrue", T);
	    volScalarField gDiffField("gDiff", T);
	    for (label i = 0; i < gField.internalField().size(); i++)
            {
                auto cy = mesh.C()[i].component(vector::Y);

                if(cy <= 0.003)//CAREFULL!
		{
		    gField.ref()[i] = g(j);
		    gTrueField.ref()[i] = gTrue(j);
		    gDiffField.ref()[i] = abs((g(j) - gTrue(j)) / gTrue(j));
                    j++; 
		    
                }
		else
		{
		    gField.ref()[i] = 0.0;
		    gTrueField.ref()[i] = 0.0;
		    gDiffField.ref()[i] = 0.0;
		}
	    }
            ITHACAstream::exportSolution(gField, "1", "./results","g");
            ITHACAstream::exportSolution(gTrueField, "1", "./results","gTrue");
            ITHACAstream::exportSolution(gDiffField, "1", "./results","gDiff");
	}


	Eigen::VectorXd cellDim(const faceList & ff, const pointField & pp , const cell & cc, labelList pLabels, pointField pLocal)
        {
	    forAll (pLabels, pointi)
                   pLocal[pointi] = pp[pLabels[pointi]];

             double  xDim = Foam::max(pLocal & vector(1,0,0)) - Foam::min(pLocal & vector(1,0,0));
             double  yDim = Foam::max(pLocal & vector(0,1,0)) - Foam::min(pLocal & vector(0,1,0));
             double  zDim = Foam::max(pLocal & vector(0,0,1)) - Foam::min(pLocal & vector(0,0,1));
            
	    Eigen::VectorXd dim (3);
	    dim << xDim, yDim, zDim;
	    return dim;
	}

        int isInPlane(double cx, double cy, double cz, double Y, Eigen::VectorXd thermocoupleCellDim)
	{
	    return (cx >= mesh.C()[thermocouplesCellID (0)].component(0) - thermocoupleCellDim(0)/4 &&
                    cy >= Y - thermocoupleCellDim(1)/4 &&
                    cy <= Y + thermocoupleCellDim(1)/4 &&
                    cz >= mesh.C()[thermocouplesCellID (0)].component(2) - thermocoupleCellDim(2)/4 &&
                    cx <= mesh.C()[thermocouplesCellID (thermocouplesNum -1)].component(0) + thermocoupleCellDim(0)/4 &&
                    cz <= mesh.C()[thermocouplesCellID (thermocouplesNum -1)].component(2) + thermocoupleCellDim(2)/4
		    );
	}
	void thermocouplesInterpolation()
	{
            DataTable thermocouplesSamples;
	    DenseVector x(2);
	    volScalarField Tint ("Tint", T);
	    double thermocouplesY = mesh.C()[thermocouplesCellID (0)].component(1); //I am assuming all thermocouples are a the same y coordinate
	    labelList pLabels(mesh.cells()[thermocouplesCellID (0)].labels(mesh.faces()));
	    pointField pLocal(pLabels.size(), vector::zero);


	    Eigen::VectorXd thermocoupleCellDim = cellDim (mesh.faces(), 
	                                                   mesh.points(), 
							   mesh.cells()[thermocouplesCellID (0)], 
							   pLabels, 
							   pLocal);

	    forAll(thermocouplesCellID, thermocoupleI)
	    {
	        
		x(0) = mesh.C()[thermocouplesCellID (thermocoupleI)].component(0);
	        x(1) = mesh.C()[thermocouplesCellID (thermocoupleI)].component(2);
	        thermocouplesSamples.addSample(x,Tmeas(thermocoupleI));
	    }

	    RBFSpline rbfspline(thermocouplesSamples, RadialBasisFunctionType::GAUSSIAN);
		
	    for (label i = 0; i < Tint.internalField().size(); i++)
            {
                auto cx = mesh.C()[i].component(vector::X);
                auto cy = mesh.C()[i].component(vector::Y);
                auto cz = mesh.C()[i].component(vector::Z);
		
                if(isInPlane(cx, cy, cz, thermocouplesY, thermocoupleCellDim))
		{
		    interpolationPlane.cellID.conservativeResize (interpolationPlane.cellID.size() + 1);
		    interpolationPlane.Ttrue.conservativeResize  (interpolationPlane.cellID.size() + 1);
		    interpolationPlane.Tdirect.conservativeResize(interpolationPlane.cellID.size() + 1);
		    interpolationPlane.Tdiff.conservativeResize  (interpolationPlane.cellID.size() + 1);
		    interpolationPlane.Tsens.conservativeResize  (interpolationPlane.cellID.size() + 1);
		    interpolationPlane.cellVol.conservativeResize(interpolationPlane.cellID.size() + 1);
		    x(0) = cx;
		    x(1) = cz;
		    interpolationPlane.cellID (interpolationPlane.cellID.size() - 1) = i; // ID of the cells in the plane
		    interpolationPlane.Ttrue  (interpolationPlane.cellID.size() - 1) = rbfspline.eval(x);
		    interpolationPlane.cellVol(interpolationPlane.cellID.size() - 1) = mesh.V()[i];
		    Tint.ref()[i] = rbfspline.eval(x);
		    
                }
		else
		{
		   Tint.ref()[i] = 0.0;
		}
            }
            ITHACAstream::exportSolution(Tint, "1", "./results","Tint");

	}

};









int main(int argc, char *argv[])
{
   // argList::noParallel(); 
   // 
   // // define allowable options and arguments
   // argList::validArgs.append("interpolation");
   //  # include "setRootCase.H"  
   // const scalar interpolation(readScalar(IStringStream(args.args()[1])()));
   // Info << interpolation << endl;
    tutorial14 example(argc, argv);
    example.solveTrue(); 
    ITHACAstream::exportSolution(example.T, "1", "./results","Ttrue");
    
    example.conjugateGradient();
    
    Info<< "Max iterations condition met\n" << endl;
    
    return 0;
}
